/**
 * @title Hub Node Runner
 * @notice Starts Hub node with DHT support
 */

import { bootstrap } from '@libp2p/bootstrap';
import { kadDHT } from '@libp2p/kad-dht';
import { mplex } from '@libp2p/mplex';
import { noise } from '@chainsafe/libp2p-noise';
import { webSockets } from '@libp2p/websockets';
import express from 'express';
import { createLibp2p } from 'libp2p';
import { Database } from '../../social-network/hub/src/database.js';
import { HubService } from '../../social-network/hub/src/hub-service.js';
import { MessageValidator } from '../../social-network/hub/src/message-validator.js';
import { SyncEngine } from '../../social-network/hub/src/sync-engine.js';

export interface HubConfig {
  port: number;
  databaseUrl: string;
  rpcUrl: string;
  bootstrapNodes?: string[];
}

export async function startHub(config: HubConfig) {
  console.log('Starting Hub node...');
  console.log(`Port: ${config.port}`);
  console.log(`Bootstrap nodes: ${config.bootstrapNodes?.length || 0}`);

  const app = express();
  app.use(express.json());

  // Create libp2p node with DHT
  const peerDiscovery = [];
  if (config.bootstrapNodes && config.bootstrapNodes.length > 0) {
    peerDiscovery.push(bootstrap({ list: config.bootstrapNodes }));
  }

    components.components.logger = logger;
    return components;
  };

  const libp2pConfig: any = {
    addresses: {
      listen: [`/ip4/0.0.0.0/tcp/${config.port}/ws`]
    },
    transports: [webSockets()],
    connectionEncryption: [noise()],
    streamMuxers: [mplex()],
  };

  // Add DHT
  libp2pConfig.dht = kadDHT();
  if (peerDiscovery.length > 0) {
    libp2pConfig.peerDiscovery = peerDiscovery;
  }

  const node = await createLibp2p(libp2pConfig);

  // Log DHT events
  node.addEventListener('peer:discovery', (evt: any) => {
    console.log(`ðŸ” Discovered peer: ${evt.detail.id.toString()}`);
  });

  node.addEventListener('peer:connect', (evt: any) => {
    console.log(`âœ… Connected to peer: ${evt.detail.toString()}`);
  });

  // Initialize services
  const db = new Database(config.databaseUrl);
  const validator = new MessageValidator({
    port: config.port,
    databaseUrl: config.databaseUrl,
    nodeId: `hub-${config.port}`,
    peers: [],
    bootstrapNodes: config.bootstrapNodes,
    rpcUrl: config.rpcUrl,
    chainId: 84532,
  });
  const syncEngine = new SyncEngine(node, db, {
    port: config.port,
    databaseUrl: config.databaseUrl,
    nodeId: `hub-${config.port}`,
    peers: [],
    bootstrapNodes: config.bootstrapNodes,
    rpcUrl: config.rpcUrl,
    chainId: 84532,
  });
  const hubService = new HubService(node, db, validator, syncEngine, {
    port: config.port,
    databaseUrl: config.databaseUrl,
    nodeId: `hub-${config.port}`,
    peers: [],
    bootstrapNodes: config.bootstrapNodes,
    rpcUrl: config.rpcUrl,
    chainId: 84532,
  });

  await hubService.start();

  // Setup API
  app.get('/health', (req, res) => {
    res.json({ status: 'ok', nodeId: hubService.getNodeId() });
  });

  app.post('/api/v1/messages', async (req, res) => {
    try {
      const result = await hubService.submitMessage(req.body);
      res.json(result);
    } catch (error) {
      res.status(400).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.get('/api/v1/messages/:hash', async (req, res) => {
    try {
      const message = await hubService.getMessage(req.params.hash);
      if (!message) return res.status(404).json({ error: 'Not found' });
      res.json(message);
    } catch (error) {
      res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
    }
  });

  app.get('/api/v1/peers', (req, res) => {
    res.json({ peers: hubService.getPeers(), count: hubService.getPeers().length });
  });

  const server = app.listen(config.port, () => {
    console.log(`âœ… Hub running on port ${config.port}`);
    console.log(`   Node ID: ${hubService.getNodeId()}`);
    console.log(`   DHT: Enabled`);
    if (config.bootstrapNodes && config.bootstrapNodes.length > 0) {
      console.log(`   Bootstrap: ${config.bootstrapNodes.length} nodes`);
    }
  });

  return {
    stop: async () => {
      await hubService.stop();
      await node.stop();
      server.close();
    }
  };
}

